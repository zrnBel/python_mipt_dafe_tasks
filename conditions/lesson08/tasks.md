## Задача 1. Фиксируем прибыль

**Условие:**

Предположим, что мы занимаемся инвестициями и у нас есть некоторый портфель акций. Каждый день наш портфель приносит нам некоторый доход или убыток. Мы разработали инструмент для определения средней прибыли от наших акций за последние `n` дней - функцию `get_avg()`. Функция `get_avg()` принимает на вход действительное число - доход (если число положительное) или убыток (если число отрицательное) за данный день. На выход функция отдает действительное число - прибыль за последние `n` дней, например, за последние 30 дней. Если количество наблюдений `m` на данный момент меньше, чем требуемый период времени (`m` < `n`), функция `get_avg()` возвращает среднее за `m` дней.

У нас есть друзья инвесторы, которые оценили разработанный нами функционал и хотели бы заполучить свой экземпляр функции `get_avg()` для подсчета своего дохода в течении интересующего их промежутка времени.

Ваша задача заключается в том, чтобы реализовать функционал для получения произвольного числа независимых функций `get_avg()`.

Допишите код в файле [task1](https://github.com/EvgrafovMichail/python_mipt_dafe_tasks/blob/main/solutions/lesson08/task1.py).

**Входные данные:**

- при создании функции `get_avg()` в качестве входа выступает натуральное число `n` - период времени, используемый для расчета;
- при вызове функции `get_avg()` в качестве входа выступает действительное число - прибыль за данный день;

**Выходные данные:**

- при создании функции `get_avg()` в качестве выхода выступает функция `get_avg()`;
- при вызове функции `get_avg()` в качестве выхода выступает действительное число - средняя прибыль за последние `n` дней или за последние `m` дней, где `m` - количество наблюдений на данный момент и `m` < `n`;

**Примеры:**

```python
# первый пример
get_avg = make_averager(2)

assert math.isclose(get_avg(1), 1)
assert math.isclose(get_avg(2), 1.5)
assert math.isclose(get_avg(3), 2.5)
assert math.isclose(get_avg(-3), 0)
assert math.isclose(get_avg(5), 1)
assert math.isclose(get_avg(5), 5)

# второй пример
get_avg = make_averager(5)

assert math.isclose(get_avg(1), 1)
assert math.isclose(get_avg(2), 1.5)
assert math.isclose(get_avg(3), 2)
assert math.isclose(get_avg(4), 2.5)
assert math.isclose(get_avg(5), 3)
assert math.isclose(get_avg(-5), 1.8)
assert math.isclose(get_avg(-7), 0)
assert math.isclose(get_avg(-2), -1)
```

# Задача 2: Ложь, Наглая ложь и Статистика

**Условие:**

Предположим, что мы работаем в отделе аналитики некоторой компании. В компании также существуют другие отделы, которые разрабатывают некоторые функции для осуществления сложных вычислений. Также в нашей компании существует отдел планирования, который следит за исполнением сроков реализации той или иной функции, и в случае, если разработка затягивается, начинает торопить разработчиков. В таком случае разработчики пишут медленный код на скорую руку, что расстраивает заказчиков.

Наша задача, как аналитиков, собрать статистику по проблемным функциям. Нас интересует количество вызовов функции, а также среднее время выполнения функции. Все статистики собираются в отдельную базу данных - специальный словарь. Затем собранная информация будет использована для принятия решений об исправлении самых неоптимальных функций. Собранные статистики хранятся в следующем виде:
`{"func_name": [time_avg, call_counter]}`

Ваша задача - реализовать функционал для сбора статистик в виде параметризованного декоратора.

Допишите код в файле [task2](https://github.com/EvgrafovMichail/python_mipt_dafe_tasks/blob/main/solutions/lesson08/task2.py).

**Входные данные:**

- на вход параметризованному декоратору подается словарь, в который и будут сохраняться собранные данные. 

**Выходные данные:**

- при каждом вызове продекорированной функции должно происходить обновление счетчика вызовов и среднего времени расчета в словаре статистик.

**Примечание:**

Для фиксирования времени работы вам потребуется встроенная библиотека `time`. Импортируйте библиотеку в ваш код с помощью следующей инструкции:
```python
import time
```

Чтобы получить текущее время в секундах, осуществите вызов:
```python
time.time()
```

**Примеры:**

```python
statistics: list[str, list[float, int]] = {}

@collect_statistic(statistics)
def func1() -> None:
    time.sleep(2)

@collect_statistic(statistics)
def func2() -> None:
    time.sleep(1)

for _ in range(3):
    func1()

for i in range(6):
    func2()

eps = 1e-3

assert statistics[func1.__name__][1] == 3
assert statistics[func2.__name__][1] == 6
assert math.isclose(statistics[func1.__name__][0], 2, abs_tol=eps)
assert math.isclose(statistics[func2.__name__][0], 1, abs_tol=eps)
```
